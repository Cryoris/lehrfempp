/**
 * @file
 * @brief We build a tensor product mesh on a torus and apply uniform refinement
 * @author Anian Ruoss
 * @date   2018-10-20 16:27:17
 * @copyright MIT License
 */

#include <iostream>

#include <lf/refinement/mesh_hierarchy.h>
#include "lf/io/io.h"

int main(int argc, char **argv) {
  int num_steps = 4;
  using size_type = lf::base::size_type;

  std::shared_ptr<lf::mesh::hybrid2dp::MeshFactory> mesh_factory_ptr =
      std::make_shared<lf::mesh::hybrid2dp::MeshFactory>(3);

  // build tensor product mesh by specifying rectangle from which torus will 
  // be generated by identifying opposite edges
  lf::mesh::hybrid2d::TorusMeshBuilder builder(mesh_factory_ptr);
  builder.setBottomLeftCorner(Eigen::Vector2d{0, 0});
  builder.setTopRightCorner(Eigen::Vector2d{1, 4});
  builder.setNoXCells(4);
  builder.setNoYCells(4);
  std::shared_ptr<lf::mesh::Mesh> mesh_ptr = builder.Build();

  // output mesh information
  const lf::mesh::Mesh &mesh = *mesh_ptr;
  lf::mesh::utils::PrintInfo(mesh, std::cout);
  std::cout << std::endl;

  // build mesh hierarchy
  lf::refinement::MeshHierarchy multi_mesh(mesh_ptr, mesh_factory_ptr);

  for (int step = 0; step < num_steps; ++step) {
    // obtain pointer to mesh on finest level
    const size_type n_levels = multi_mesh.NumLevels();
    std::shared_ptr<const lf::mesh::Mesh> mesh_fine =
        multi_mesh.getMesh(n_levels - 1);

    // print number of entities of various co-dimensions
    std::cout << "Mesh on level " << n_levels - 1 << ": " << mesh_fine->Size(2)
              << " nodes, " << mesh_fine->Size(1) << " edges, "
              << mesh_fine->Size(0) << " cells," << std::endl;

    lf::io::writeMatplotlib(*mesh_fine, std::string("torus_refinement") +
                                            std::to_string(step) + ".csv");

    multi_mesh.RefineRegular();
  }

  return 0;
}
